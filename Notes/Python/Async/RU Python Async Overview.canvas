{
	"nodes":[
		{"id":"95d2c104c01c39c2","type":"group","x":-511,"y":8880,"width":2600,"height":2480,"label":"Синхронизация кода"},
		{"id":"046b86d6e0de2d15","type":"group","x":-511,"y":6280,"width":2600,"height":2400,"label":"\n\n\n\n\n\n\n\nЗадачи и параллелизм"},
		{"id":"136598aefe9f827e","type":"group","x":-740,"y":-1640,"width":2107,"height":1487,"label":"GIL"},
		{"id":"550bb4cdb88d00dc","type":"group","x":-439,"y":5040,"width":2457,"height":1010,"label":"\n\n\n\n\n\n\n\nОсновные функции и синтаксис asyncio"},
		{"id":"87bca9eb62cc9614","type":"group","x":149,"y":3280,"width":1283,"height":1569,"label":"\n\n\n\n\n\n\n\nAwaitable и объектная модель asyncio"},
		{"id":"16affb269abfc7bf","type":"group","x":-1210,"y":-2806,"width":1830,"height":1046,"label":"Потоки и процессы"},
		{"id":"b94e48789e2c785c","type":"group","x":-300,"y":0,"width":1353,"height":1080,"label":"Сокеты"},
		{"id":"cd4744afca6bcc2d","type":"group","x":-2760,"y":-2711,"width":1353,"height":857,"label":"Многозадачность"},
		{"id":"560c93ab6f9ab266","type":"group","x":500,"y":1340,"width":581,"height":1740,"label":"Концепции Asyncio "},
		{"id":"1ad33772b27e73f6","type":"group","x":1200,"y":1720,"width":960,"height":663,"label":"Ошибки при организации многозадачности"},
		{"id":"421cfe113ad8fe7b","type":"group","x":-26,"y":-2806,"width":646,"height":180,"color":"5","label":"Память потоков и процессов"},
		{"id":"1f3a529c5bba4526","type":"text","text":"Обычное Python приложение создает **процесс и главный поток**","x":-650,"y":-2580,"width":334,"height":120,"color":"5"},
		{"id":"852a9cbd4c9159f7","type":"text","text":"**С каждым процессом по умолчанию связан по крайней мере один поток — главный**.\n\nПроцесс может создавать дополнительные рабочие (фоновые) потоки.","x":-212,"y":-2333,"width":320,"height":205},
		{"id":"f159503df922190b","type":"text","text":"#### C-расширения, которые явно освобождают GIL\n\nПри вызове внешних C-функций можно управлять GIL явно:\n- В cffi есть опция `with gil / without gil`\n- В ctypes можно обернуть вызов в C-функцию, которая вручную отпустит GIL","x":-482,"y":-520,"width":467,"height":309},
		{"id":"f484c000acdf5802","type":"text","text":"### I/O операции\n\nGIL освобождается на время выполнения I/O операций\n- Работа с сокетами\n- Чтение/запись в файл\n- Обращение к базам данных через C-расширения\n","x":133,"y":-520,"width":467,"height":309},
		{"id":"c082273cc0582aa1","type":"text","text":"#### Встроенные функции и модули, реализованные на C\n\n- Пример: zlib, bz2, hashlib, json, sqlite3, PIL — при выполнении тяжелых операций внутри себя могут отпускать GIL.\n    \n- NumPy и SciPy часто отпускают GIL при выполнении математических операций (в зависимости от реализации).","x":760,"y":-520,"width":467,"height":309},
		{"id":"ecddfe86f51804bf","type":"text","text":"## Сокет\nСокет — абстракция отправки и получения данных\n2 операции основные\n- отправка байтов\n- получение байтов","x":121,"y":62,"width":490,"height":258},
		{"id":"da6716373fe172d4","type":"text","text":"### Блокирующие сокеты\nИспользуются по умолчанию\n**Приостанавливают приложение на все время ожидания ответа**","x":-280,"y":380,"width":401,"height":336},
		{"id":"f988f3f4375d9ab4","type":"text","text":"### Неблокирующие сокеты\nМожно выполнять другие задачи, а затем **ОС уведомляет, что байты получены** и мы можем вернуться к обработке\n\nЗа уведомления отвечают разные утилиты в зависимости от ОС\n- kqueue - MacOS, FreeBSD\n- epoll - Linux\n- IOCP - Windows","x":599,"y":380,"width":378,"height":362},
		{"id":"6bd90b308626e056","type":"text","text":"**ОС следит за неблокирующими сокетами и сообщает, когда в них появляются данные, а один поток с asyncio обрабатывает эти события, обеспечивая кооперативную конкурентность без многопоточности.**\n\n#### Это лежит в основне конкурентности asyncio","x":543,"y":780,"width":490,"height":280,"color":"3"},
		{"id":"ac80ac6a020a78c5","type":"text","text":"### Вытесняющая\nОперационная система решает, как переключать задачи, используя механизм квантования времени.\n","x":-2740,"y":-2500,"width":373,"height":239},
		{"id":"40993f24e786a799","type":"text","text":"# Многозадачность\n","x":-2484,"y":-2691,"width":341,"height":70},
		{"id":"197a2c6431913afa","type":"text","text":"### Кооперативная\nЗадачи сами определяют точки (например, с помощью await), где они временно приостанавливают выполнение и уступают управление другим задачам","x":-2267,"y":-2500,"width":373,"height":239},
		{"id":"c20933b26166dd5b","type":"text","text":"При кооперативной многозадачности задача может приостановить выполнение (заснуть) и передать управление другой — это создаёт форму конкурентности: несколько задач активны одновременно на уровне логики, но не параллельно, поскольку исполняются поочерёдно в одном потоке.\n\n**Asyncio реализует именно такую модель**","x":-2272,"y":-2181,"width":383,"height":290},
		{"id":"d2a8b5499bdd9de4","type":"text","text":"# GIL\n**GIL разрешает только одному потоку интерпретатора Python исполнять байткод в каждый момент времени.**\n\nИз-за этого многопоточность в Python почти не даёт выигрыша в вычислительных задачах, за исключением операций ввода-вывода и вызовов внешнего кода (например, C-библиотек), не зависящих от GIL.","x":133,"y":-1580,"width":467,"height":320,"color":"6"},
		{"id":"8752d3d68fb10c7c","type":"text","text":"### Операции, освобождающие GIL\n\nНизкоуровневые системы, которые **работают за пределами среды Python**","x":133,"y":-760,"width":467,"height":180},
		{"id":"c24d1be1240bfdb0","type":"text","text":"Рабочий поток","x":424,"y":-2696,"width":176,"height":50,"color":"4"},
		{"id":"44a68b105f19162b","type":"text","text":"# Связь процессов и потоков\n","x":-698,"y":-2786,"width":431,"height":98},
		{"id":"ca7b81d1f96e8629","type":"text","text":"Главный поток","x":-6,"y":-2696,"width":188,"height":50,"color":"4"},
		{"id":"58e33e1ca9c99f46","type":"text","text":"# Многопоточность\nПроцесс может порождать много потоков, которые  **разделяют память с процессом-родителем** и работают конкурентно.\n","x":133,"y":-2008,"width":467,"height":208},
		{"id":"0748ab1e70e639e7","type":"text","text":"**Память процесса**","x":202,"y":-2786,"width":192,"height":50,"color":"3"},
		{"id":"591966c265a358e7","type":"text","text":"# Поток\nПотоки **не имеют своей выделенной памяти**, а пользуются памятью родительского ПРОЦЕССА","x":206,"y":-2333,"width":320,"height":205,"color":"4"},
		{"id":"13382b344a59130c","type":"text","text":"# Процесс\nПриложение, которому **выделена собственная область памяти**, недоступная другим приложениям","x":-650,"y":-2333,"width":334,"height":205,"color":"3"},
		{"id":"7e7dda3378a2777f","type":"text","text":"Рабочий поток","x":210,"y":-2696,"width":177,"height":50,"color":"4"},
		{"id":"049a3ce0bbd301dd","type":"text","text":"- Потребляет меньше ресурсов\n- Гранулярность - явно помечаем наиболее выгодные точки для приостановки","x":-1800,"y":-2450,"width":373,"height":140},
		{"id":"f5c9abb850849a24","type":"text","text":"**На многоядерном процессоре** могут работать несколько процессов ОДНОВРЕМЕННО","x":-1190,"y":-2387,"width":366,"height":113},
		{"id":"70d16cb22d93995b","type":"text","text":"**На одноядерном процессоре** также возможна конкурентная работа, но за счёт ОС и квантования времени","x":-1190,"y":-2207,"width":366,"height":107},
		{"id":"155bff9542a5538c","type":"text","text":"## Многопроцессность\nПроцесс может порождать новые процессы, управлять ими и распределять работу.\nПри этом **каждый процесс имеет собственную выделенную память.**","x":-716,"y":-2008,"width":467,"height":208},
		{"id":"1538d5c481574fa0","type":"text","text":"# Синхронизация кода","x":459,"y":8960,"width":600,"height":80,"color":"1"},
		{"id":"9c9bde0e160eb265","type":"text","text":"## Ошибки в однопоточная конкурентность\n\n Так как asyncio использует модель **однопоточной конкурентности**, состояние гонки здесь возможно **только при наличии await между обращениями к общим данным**. \n Это отличается от многопоточности, где гонки могут возникать **в любой момент** модификации разделяемых ресурсов.\n\n\n```\nimport asyncio  \n  \nn = 0  \nlock = asyncio.Lock()  \n  \nasync def increment():  \n    global n  \n    temp_n = n  \n    await asyncio.sleep(0.01)  \n    n = temp_n + 1  \n  \nasync def main():  \n    global n  \n    await asyncio.gather(*[increment() for _ in range(100)])  \n    print(n)  \n    assert n == 100\n```\n\n**В модели однопоточной конкурентности ошибки, связанные с неатомарными операциями, не возникают, если между ними нет await.**\n\nНапример, инкрементация целого числа (n += 1) — неатомарна: она состоит из чтения, увеличения и записи.\n\nОднако если выполнение не может быть прервано (т.е. нет await между этими действиями), состояние гонки не возникает.\n\nПоэтому если убрать await asyncio.sleep(0.01) из примера выше, программа будет работать корректно и результат всегда будет ожидаемым.","x":-221,"y":9280,"width":600,"height":1020},
		{"id":"8b79bef53fcde5bd","type":"text","text":"## asyncio.Semaphore\nОграничивает **количество одновременно выполняющихся задач**.\n\nПри достижении лимита — новые задачи ждут освобождения. Это ограничивает “параллельность”, например, при работе с API, БД, файлами.\n\n---\n\n```\nsem = asyncio.Semaphore(3)\nasync def limited_task(n):\n    async with sem:\n        print(f\"Start {n}\")\n        await asyncio.sleep(2)\n        print(f\"End {n}\")\n\nasync def main():\n    tasks = [limited_task(i) for i in range(6)]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n```\n\n- Одновременно начнутся **только 3 задачи** (0, 1, 2).\n    \n- Остальные (3, 4, 5) будут **ожидать**, пока освободится слот.\n    \n- После завершения первых — начнутся следующие.","x":459,"y":9280,"width":600,"height":1020},
		{"id":"224c426bcecbfb51","type":"text","text":"## asyncio.BoundedSemaphore\nТо же, что Semaphore, но выбрасывает ошибку, если попытаться высвободить больше, чем захвачено.\nПолезно для отладки неправильного использования семафора.\n\n**Это невозможно, если вы всегда используете семафоры через контекстный менеджер `async with Semaphore(...)`**\n\n\n---\n\n```\nasync def limited_task():\n\tsem = asyncio.BoundedSemaphore(2)\n\n    await sem.acquire()\n    sem.release()\n    sem.release()  # ValueError: BoundedSemaphore released too many times\n\nasyncio.run(limited_task())\n```\n","x":1139,"y":9280,"width":600,"height":1020},
		{"id":"10f46d91bcaf7be8","type":"text","text":"## asyncio.Lock\nАсинхронный **взаимно исключающий замок** (mutex).\n\nПозволяет гарантировать, что **только одна задача** выполняет критическую секцию кода одновременно.\n\n---\n\n```\nimport asyncio  \n\nn = 0  \nlock = asyncio.Lock()  \nasync def increment():  \n  global n  \n  async with lock:  \n      temp_n = n  \n      await asyncio.sleep(0.01)  \n      n = temp_n + 1    \n\nasync def main():  \n  global n  \n  await asyncio.gather(*[increment() for _ in range(1000)])  \n  assert n == 1000  \n  \nasyncio.run(main())\n```\n\n\n","x":-221,"y":10380,"width":600,"height":900},
		{"id":"2a31f2f086ffc165","type":"text","text":"### asyncio.create_task\nФункция `asyncio.create_task(coro)` создаёт задачу из корутины и планирует её выполнение в цикле событий\n\nПозволяет запускать несколько корутин конкурентно — они выполняются независимо, пока к ним не применят `await`\n\n**Задача начинает выполняться как можно раньше, не блокируя остальной код.**\n\n```\ntask = asyncio.create_task(do_something())\n```","x":564,"y":7120,"width":485,"height":420},
		{"id":"4109df72862e8b17","type":"text","text":"### asyncio.wait\nПозволяет ждать завершения набора задач.\nВозвращает два множества: done и pending.\n\n---\n**asyncio.wait() не оборачивает корутины в Task!!**\n\n> Обратите внимание, если не использовать `create_task`, то корутины начнут выполнение только при встрече `await`.  В этом случае **нет конкурентности**, всё идёт по очереди\n\nПравильное использование с `create_task`\n```\ndone, pending = await asyncio.wait([\n  asyncio.create_task(do_1()),\n  asyncio.create_task(do_2())\n])\n```\n\n\nПараметр `return_when` управляет моментом возврата:\n- ALL_COMPLETED — ждёт завершения **всех задач** (по умолчанию).\n    \n- FIRST_COMPLETED — возвращает, когда **первая задача завершена**.\n    \n- FIRST_EXCEPTION — возвращает, как только **первая задача выбросит исключение**.","x":865,"y":7680,"width":514,"height":880},
		{"id":"10c89f4f34232a41","type":"text","text":"## Снятие задач\n\n- **task.cancel()** - возбуждает CanceledError. Не прерывает задачу, а снимает только если она находится в точке await\n\n- **asyncio.wait_for()**  - задает таймаут перед снятием задач\n- **asyncio.shield()** - позволяет задаче игнорировать запросы на снятие","x":1162,"y":6607,"width":520,"height":403},
		{"id":"5611456618bf3223","type":"text","text":"### asyncio.wait_for\nПозволяет задать таймаут выполнения корутины.\nЕсли корутина не завершится за указанное время — выбрасывается `asyncio.TimeoutError`.\n\n---\n**asyncio.wait_for() автоматически оборачивает корутины в Task**\n\n```\nawait asyncio.wait_for(do_something(), timeout=5)\n```\n\n\n> Если задача превышает таймаут — её выполнение **отменяется** (можно перехватить CancelledError внутри).","x":1488,"y":7680,"width":514,"height":880},
		{"id":"95f7089ba04662c3","type":"text","text":"# Задачи и параллелизм","x":542,"y":6400,"width":529,"height":77,"color":"1"},
		{"id":"bf9cc2b7aa7f9fa2","type":"text","text":"### task\n\nЗадача (`asyncio.Task`) — это обёртка вокруг корутины, которая автоматически планирует её выполнение в цикле событий.  \n\nПосле создания задача ставится в очередь и начинает выполняться при первой возможности.  \n\nСоздание задачи не блокирует выполнение программы — event loop продолжает обрабатывать другие задачи.","x":564,"y":6600,"width":485,"height":417},
		{"id":"4167136b707d3145","type":"text","text":"### asyncio.gather\nПозволяет конкурентно выполнять несколько корутин и ждать их завершения.\n\nВсе корутины запускаются одновременно, а результаты возвращаются в виде списка **в том же порядке, в каком были переданы в asyncio.gather, независимо от порядка их завершения**.\n\n---\n**asyncio.gather() автоматически оборачивает корутины в Task**\n\n```\nawait asyncio.gather(do_1(), do_2(), do_3())\n```\n\nЕсли передать return_exceptions=True, gather не прерывается при исключениях — вместо этого возвращает их в результирующем списке.\nЭто позволяет обработать ошибки вручную без падения всей группы задач.\n```\nresults = await asyncio.gather(\n    do_ok(), do_fail(), return_exceptions=True\n)\n# results = [result, Exception(...)]\nfor i, result in enumerate(results):\n\tif isinstance(result, Exception):\n\t\tprint(f\"Task {i} raised an exception\")\n    else:\n\t\tprint(f\"Task {i} completed successfully\")\n```","x":-395,"y":7680,"width":514,"height":900},
		{"id":"be04caa1a466a87a","type":"text","text":"### asyncio.as_completed\nИтератор, возвращающий результаты по мере завершения корутин. Не ждёт всех сразу. **Порядок результатов соответствует порядку завершения, а не вызова.**\n\n---\n**asyncio.as_completed() не оборачивает корутины в Task!!**\n\n> Обратите внимание, если не использовать `create_task`, то корутины начнут выполнение только при встрече `await`.  В этом случае **нет конкурентности**, всё идёт по очереди\n\n```\nfor coro in asyncio.as_completed([\n  do_1(), do_2()\n]):\n    result = await coro\n```\nПравильное использование с `create_task`\n```\nfor task in asyncio.as_completed([\n  asyncio.create_task(do_1()),\n  asyncio.create_task(do_2())\n]):\n    result = await task\n```","x":245,"y":7680,"width":514,"height":880},
		{"id":"3d32df03720436ca","type":"text","text":"### Основные объекты asyncio","x":530,"y":3320,"width":529,"height":77,"color":"1"},
		{"id":"b766d96f64eae88e","type":"text","text":"### Awaitable\n\nAбстракция, которая описывает любой объект, который может быть “ожидаем” с помощью await.\n- Определён единственный абстрактный метод `__await__`\n- Все объекты, которые можно использовать с await, реализуют этот метод.","x":527,"y":3480,"width":535,"height":260},
		{"id":"18c42c0cb1073c81","type":"text","text":"###  **Future** (наследует Awaitable)\nОбъект, представляющий результат, который станет доступен в будущем.\n\n- При создании считается **незаполненным** (incomplete).\n    \n- Когда результат готов (устанавливается вручную или автоматически), он становится доступным через .result() или await.","x":890,"y":3900,"width":512,"height":520},
		{"id":"12de8bee1dbdb9fd","type":"text","text":"###  **Coroutine** (наследует Awaitable)\nКорутина в python выглядит как обычная функция с особенностью: **может приостанавливаться на время длительной операции**\n\n- **async** - определяет корутину\n- **await** - приостанавливает выполнение до получения результата\n\n**Корутины не выполняются, если их вызывать напрямую. Они возвращают объект корутины!**\n\nЧтобы выполнить корутину, нужно явно передать ее циклу событий\n- либо await-ить напрямую,\n- либо обернуть в Task через asyncio.create_task()","x":169,"y":3912,"width":508,"height":508},
		{"id":"61613bc7a7eba894","type":"text","text":"### Основные функции и синтаксис asyncio","x":516,"y":5070,"width":529,"height":77,"color":"1"},
		{"id":"43a350b38a0da79e","type":"text","text":"### async def\n\nОпределяет **корутину** — специальную функцию, которую можно приостанавливать с помощью await.\n\n```\nasync def fetch():\n    await asyncio.sleep(n)\n    return f\"Done {n}\"\n```\n\n**Корутину нельзя просто вызвать — она возвращает coroutine-объект. Чтобы выполнить её, нужно применить await или обернуть в Task.**\n\n```\nresult = fetch(1)\nprint(result)\n# <coroutine object fetch at 0x...>\n\n\nresult = await fetch(1)\nprint(result)\n# Done 1\n```","x":-419,"y":5328,"width":470,"height":682},
		{"id":"e7b32395e995cf35","type":"text","text":"### await\n\nПриостанавливает сопрограмму. Код внутри нее не выполняется, пока не вернется значение для await.\nПри этом не блокирует поток, а позволяет другим задачам выполняться параллельно\n```\nasync def fetch(n):\n    await asyncio.sleep(n)\n    return f\"Done {n}\"\n\nawait fetch(1)\n```\n---\n> Обратите внимание: при таком использовании (последовательный await), вызовы выполняются один за другим, как в синхронном коде.\n```\nasync def main():\n\tresult_1 = await fetch(1)\n\tresult_2 = await fetch(2)\n\tresult_3 = await fetch(3)\n```","x":181,"y":5328,"width":547,"height":682},
		{"id":"ff31d17fd0b31d77","type":"text","text":"### asyncio.run()\n\nСоздает новый цикл событий, выполняет код переданной корутины до конца и возвращает результат. В конце останавливает и закрывает цикл событий.\n\nЗадумана, как главная точка входа в приложение asyncio. Выполняет только одну корутину, которая должна обработать все остальные\n\n```  \nasync def fetch(n):\n    await asyncio.sleep(n)\n    return f\"Done {n}\"\n\nasync def main():\n\tresults = await asyncio.gather(\n        fetch(1),\n        fetch(2),\n        fetch(3)\n    )\n    for r in results:\n        print(r)\n\nasyncio.run(main())\n```","x":807,"y":5328,"width":547,"height":682},
		{"id":"385f7abe3da08828","type":"text","text":"### asyncio.sleep()\n\nАсинхронная пауза, **не блокирует** выполнение других задач.\nИспользуется для:\n- симуляции I/O\n- троттлинга\n- создания задержек без блокировки цикла событий\n\nВ отличие от time.sleep(), не останавливает поток.","x":1451,"y":5328,"width":547,"height":682},
		{"id":"08d7a721119fd9b9","type":"text","text":"1. Бесконечный цикл на каждой итерации проверяет, есть ли готовая задача в очереди\n\t1.  Если есть, то она **выполняется, пока не встретит I/O операцию**\n\t2. В этот момент задача **приостанавливается и мы \"просим\" ОС наблюдать за сокетами**\n2. В это время переходим к следующей готовой задаче\n3. На каждой итерации проверяется, есть ли задача, для которой закончилась I/O операция\n\t1. Если есть, она пробуждается и продолжает работу","x":519,"y":2680,"width":535,"height":380},
		{"id":"3436cd773d7353fe","type":"text","text":"# Asyncio\n\nБиблиотека в Python для написания **асинхронного, однопоточного кода**, эффективно работающего с **I/O-операциями** (сети, файлы и т.п.) без блокировки исполнения.\n","x":528,"y":1402,"width":516,"height":181,"color":"1"},
		{"id":"2da27f2c5effa163","type":"text","text":"#### Выполнение счётного кода в задачах и корутинах без многопроцессности\n\nasyncio работает в одном потоке, поэтому остаются ограничения GIL.","x":1220,"y":1934,"width":431,"height":283},
		{"id":"c362a13406e29de4","type":"text","text":"**Можно решить путем многопроцессности**","x":1220,"y":2294,"width":431,"height":69},
		{"id":"e324d7f660346594","type":"text","text":"## Основные ошибки","x":1554,"y":1742,"width":301,"height":60},
		{"id":"ca8ffb6cba38b33b","type":"text","text":"#### Использование блокирующих I/O API без многопоточности\n\nПримеры: requests, time.sleep, boto3 и другие.\n\nВ общем случае — любая функция, выполняющая I/O и не являющаяся корутиной, считается блокирующей.","x":1704,"y":1934,"width":431,"height":283},
		{"id":"c9926edb6dd93834","type":"text","text":"**Можно решить путем многопоточности**","x":1704,"y":2294,"width":431,"height":63},
		{"id":"3a6858a48bd933d3","type":"text","text":"### **Task** (наследует Future)\nСпециализированный Future, который оборачивает корутину и управляет её выполнением в event loop’е.\n- Управляет жизненным циклом корутины.\n- При завершении записывает результат или исключение во внутренний Future.","x":880,"y":4500,"width":533,"height":309},
		{"id":"e952960c344a59ad","type":"text","text":"## Однопоточная конкурентность\n\nДля конкурентной обработки I/O достаточно одного потока и одного процесса. Это возможно благодаря тому, что операции ввода-вывода выполняются конкурентно на уровне операционной системы.\n\n**Асинхронная конкурентность** в asyncio базируется:\n\n- на **реактивной обработке I/O** (оповещения от ОС),\n    \n- и на **кооперативной передаче управления** между задачами (через await).\n","x":541,"y":1960,"width":490,"height":369},
		{"id":"f6a7a49ed5cadaed","type":"text","text":"## Цикл событий\n\nCердце любого asyncio приложения\n\nСоздается очередь, в которую добавляются события или сообщения, которые затем обрабатываются в бесконечном цикле по мере поступления","x":546,"y":2363,"width":480,"height":280},
		{"id":"d584fcef1073d8b5","type":"text","text":"## Asyncio НЕ ОБХОДИТ GIL\n\n#### Asyncio использует освобождение GIL при I/O операциях\nДля конкурентного выполнения счетных операций все-равно придется заводить отдельный ПРОЦЕСС","x":528,"y":1642,"width":516,"height":260,"color":"1"},
		{"id":"851e50e0d0d6807b","type":"text","text":"### ПОЧЕМУ GIL СУЩЕСТВУЕТ?\n\nВ интерпретаторе CPython управление памятью в основном основано на подсчёте ссылок.\n\n**Подсчёт ссылок — неатомарная операция, включающая чтение и запись.**\n\nИз-за этого CPython не является потокобезопасным:\n\n- **если несколько потоков одновременно модифицируют переменную, её значение может быть повреждено из-за состояния гонки**","x":133,"y":-1220,"width":467,"height":418},
		{"id":"94457a7b1635634a","type":"text","text":"##### Многопроцессные приложения могут работать одновременно так как у **каждого процесса свой GIL**\n","x":-716,"y":-1510,"width":467,"height":180,"color":"#fa7900"}
	],
	"edges":[
		{"id":"8a46ef9e02f78daa","fromNode":"13382b344a59130c","fromSide":"left","toNode":"f5c9abb850849a24","toSide":"right"},
		{"id":"38f881b55aa2673f","fromNode":"13382b344a59130c","fromSide":"left","toNode":"70d16cb22d93995b","toSide":"right"},
		{"id":"af872800397f7dc0","fromNode":"155bff9542a5538c","fromSide":"bottom","toNode":"94457a7b1635634a","toSide":"top"},
		{"id":"5b36b14fb76c87cc","fromNode":"13382b344a59130c","fromSide":"bottom","toNode":"155bff9542a5538c","toSide":"top"},
		{"id":"2a00a9dc819ba562","fromNode":"13382b344a59130c","fromSide":"right","toNode":"852a9cbd4c9159f7","toSide":"left"},
		{"id":"c22d8f14c63a7386","fromNode":"1f3a529c5bba4526","fromSide":"bottom","toNode":"13382b344a59130c","toSide":"top"},
		{"id":"81b0f238116bfca4","fromNode":"58e33e1ca9c99f46","fromSide":"bottom","toNode":"d2a8b5499bdd9de4","toSide":"top"},
		{"id":"ba60b534c82c0f14","fromNode":"591966c265a358e7","fromSide":"bottom","toNode":"58e33e1ca9c99f46","toSide":"top"},
		{"id":"1f96b46abee5befb","fromNode":"852a9cbd4c9159f7","fromSide":"right","toNode":"591966c265a358e7","toSide":"left"},
		{"id":"de29b625d53076ee","fromNode":"94457a7b1635634a","fromSide":"right","toNode":"d2a8b5499bdd9de4","toSide":"left"},
		{"id":"d3eb79767f1e9244","fromNode":"8752d3d68fb10c7c","fromSide":"left","toNode":"f159503df922190b","toSide":"top"},
		{"id":"38d2c8d082295f19","fromNode":"8752d3d68fb10c7c","fromSide":"bottom","toNode":"f484c000acdf5802","toSide":"top"},
		{"id":"489ab9f6ae13d269","fromNode":"8752d3d68fb10c7c","fromSide":"right","toNode":"c082273cc0582aa1","toSide":"top"},
		{"id":"db9b38fabe27fedf","fromNode":"44a68b105f19162b","fromSide":"bottom","toNode":"1f3a529c5bba4526","toSide":"top"},
		{"id":"71a59b459ba67f3f","fromNode":"40993f24e786a799","fromSide":"bottom","toNode":"ac80ac6a020a78c5","toSide":"top"},
		{"id":"1df22f389e38e944","fromNode":"40993f24e786a799","fromSide":"bottom","toNode":"197a2c6431913afa","toSide":"top"},
		{"id":"6cde1446c0d03d7f","fromNode":"197a2c6431913afa","fromSide":"right","toNode":"049a3ce0bbd301dd","toSide":"left"},
		{"id":"f73bd6e1724eb49f","fromNode":"197a2c6431913afa","fromSide":"bottom","toNode":"c20933b26166dd5b","toSide":"top"},
		{"id":"49c460e2693695d4","fromNode":"e952960c344a59ad","fromSide":"bottom","toNode":"f6a7a49ed5cadaed","toSide":"top"},
		{"id":"cc1bf1a8a93c9e4a","fromNode":"f6a7a49ed5cadaed","fromSide":"bottom","toNode":"08d7a721119fd9b9","toSide":"top"},
		{"id":"e3dd9518f8ca0fb3","fromNode":"ecddfe86f51804bf","fromSide":"right","toNode":"f988f3f4375d9ab4","toSide":"top"},
		{"id":"0ec3473b12c4cb81","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"e7b32395e995cf35","toSide":"top"},
		{"id":"fbfe9e1e5a89cef6","fromNode":"bf9cc2b7aa7f9fa2","fromSide":"bottom","toNode":"2a31f2f086ffc165","toSide":"top"},
		{"id":"b2cf212cf31fca48","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"ff31d17fd0b31d77","toSide":"top"},
		{"id":"46198a40a7995535","fromNode":"3d32df03720436ca","fromSide":"bottom","toNode":"b766d96f64eae88e","toSide":"top"},
		{"id":"aeea8b8afe696774","fromNode":"b766d96f64eae88e","fromSide":"bottom","toNode":"12de8bee1dbdb9fd","toSide":"top"},
		{"id":"f77ce16252af4e5f","fromNode":"b766d96f64eae88e","fromSide":"bottom","toNode":"18c42c0cb1073c81","toSide":"top"},
		{"id":"761e4b22992cf394","fromNode":"ecddfe86f51804bf","fromSide":"left","toNode":"da6716373fe172d4","toSide":"top"},
		{"id":"af4a7e3b119621ea","fromNode":"18c42c0cb1073c81","fromSide":"bottom","toNode":"3a6858a48bd933d3","toSide":"top"},
		{"id":"618c0f1fa5474eaa","fromNode":"e324d7f660346594","fromSide":"bottom","toNode":"2da27f2c5effa163","toSide":"top"},
		{"id":"ca1f91146802e39d","fromNode":"e324d7f660346594","fromSide":"bottom","toNode":"ca8ffb6cba38b33b","toSide":"top"},
		{"id":"2ab5170f7f968ce2","fromNode":"2da27f2c5effa163","fromSide":"bottom","toNode":"c362a13406e29de4","toSide":"top"},
		{"id":"a1b133c9ee07965f","fromNode":"ca8ffb6cba38b33b","fromSide":"bottom","toNode":"c9926edb6dd93834","toSide":"top"},
		{"id":"2105d72d7fa92a67","fromNode":"f484c000acdf5802","fromSide":"bottom","toNode":"ecddfe86f51804bf","toSide":"top"},
		{"id":"98f26bb09db56f06","fromNode":"f988f3f4375d9ab4","fromSide":"bottom","toNode":"6bd90b308626e056","toSide":"top"},
		{"id":"75c7454f212a9bb5","fromNode":"6bd90b308626e056","fromSide":"bottom","toNode":"3436cd773d7353fe","toSide":"top"},
		{"id":"a5e0e0df93a5fecb","fromNode":"0748ab1e70e639e7","fromSide":"left","toNode":"ca7b81d1f96e8629","toSide":"top"},
		{"id":"466e2716840d874c","fromNode":"0748ab1e70e639e7","fromSide":"right","toNode":"c24d1be1240bfdb0","toSide":"top"},
		{"id":"3135e7b26e738086","fromNode":"0748ab1e70e639e7","fromSide":"bottom","toNode":"7e7dda3378a2777f","toSide":"top"},
		{"id":"e66d40f51c5b6013","fromNode":"3436cd773d7353fe","fromSide":"bottom","toNode":"d584fcef1073d8b5","toSide":"top"},
		{"id":"fd63ac27678ee762","fromNode":"d584fcef1073d8b5","fromSide":"bottom","toNode":"e952960c344a59ad","toSide":"top"},
		{"id":"730e029e98ab245b","fromNode":"d2a8b5499bdd9de4","fromSide":"bottom","toNode":"851e50e0d0d6807b","toSide":"top"},
		{"id":"56dea0e6872c3f58","fromNode":"851e50e0d0d6807b","fromSide":"bottom","toNode":"8752d3d68fb10c7c","toSide":"top"},
		{"id":"2423a2ae39b30559","fromNode":"d584fcef1073d8b5","fromSide":"right","toNode":"e324d7f660346594","toSide":"left"},
		{"id":"82df4c3ef522c571","fromNode":"2a31f2f086ffc165","fromSide":"bottom","toNode":"be04caa1a466a87a","toSide":"top"},
		{"id":"f90dc305fa626ac3","fromNode":"2a31f2f086ffc165","fromSide":"bottom","toNode":"4109df72862e8b17","toSide":"top"},
		{"id":"772e66ab4cec262f","fromNode":"2a31f2f086ffc165","fromSide":"left","toNode":"4167136b707d3145","toSide":"top"},
		{"id":"db4e83c7b2b30b67","fromNode":"2a31f2f086ffc165","fromSide":"right","toNode":"5611456618bf3223","toSide":"top"},
		{"id":"0132f6cc61c80227","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"43a350b38a0da79e","toSide":"top"},
		{"id":"7ebf227bcbd2fb7c","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"385f7abe3da08828","toSide":"top"},
		{"id":"8ce26e89bf81adde","fromNode":"95f7089ba04662c3","fromSide":"bottom","toNode":"bf9cc2b7aa7f9fa2","toSide":"top"},
		{"id":"996578eec0ca705e","fromNode":"bf9cc2b7aa7f9fa2","fromSide":"right","toNode":"10c89f4f34232a41","toSide":"left"},
		{"id":"e228bd290471e31e","fromNode":"550bb4cdb88d00dc","fromSide":"bottom","toNode":"046b86d6e0de2d15","toSide":"top"},
		{"id":"9c9d954badb607fc","fromNode":"87bca9eb62cc9614","fromSide":"bottom","toNode":"550bb4cdb88d00dc","toSide":"top"},
		{"id":"613cb765374dab17","fromNode":"560c93ab6f9ab266","fromSide":"bottom","toNode":"87bca9eb62cc9614","toSide":"top"},
		{"id":"f048609c86371e51","fromNode":"1538d5c481574fa0","fromSide":"bottom","toNode":"8b79bef53fcde5bd","toSide":"top"},
		{"id":"365c7999e7e9022f","fromNode":"1538d5c481574fa0","fromSide":"bottom","toNode":"224c426bcecbfb51","toSide":"top"},
		{"id":"6fc8eeed3adf0e63","fromNode":"1538d5c481574fa0","fromSide":"bottom","toNode":"9c9bde0e160eb265","toSide":"top"},
		{"id":"a2539bd831016265","fromNode":"9c9bde0e160eb265","fromSide":"bottom","toNode":"10f46d91bcaf7be8","toSide":"top"},
		{"id":"46b71ed2d772851c","fromNode":"046b86d6e0de2d15","fromSide":"bottom","toNode":"95d2c104c01c39c2","toSide":"top"},
		{"id":"7a7619de2012b30b","fromNode":"cd4744afca6bcc2d","fromSide":"right","toNode":"16affb269abfc7bf","toSide":"left"}
	]
}