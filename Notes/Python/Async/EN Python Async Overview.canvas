{
	"nodes":[
		{"id":"95d2c104c01c39c2","type":"group","x":-511,"y":8880,"width":2600,"height":2480,"label":"Code Synchronization"},
		{"id":"046b86d6e0de2d15","type":"group","x":-511,"y":6280,"width":2600,"height":2400,"label":"Tasks and Parallelism"},
		{"id":"136598aefe9f827e","type":"group","x":-740,"y":-1640,"width":2107,"height":1487,"label":"GIL"},
		{"id":"550bb4cdb88d00dc","type":"group","x":-439,"y":5040,"width":2457,"height":1010,"label":"Core asyncio Functions and Syntax"},
		{"id":"87bca9eb62cc9614","type":"group","x":149,"y":3280,"width":1283,"height":1569,"label":"Awaitables and the asyncio Object Model"},
		{"id":"16affb269abfc7bf","type":"group","x":-1210,"y":-2806,"width":1830,"height":1046,"label":"Threads and Processes"},
		{"id":"b94e48789e2c785c","type":"group","x":-300,"y":0,"width":1353,"height":1080,"label":"Sockets"},
		{"id":"cd4744afca6bcc2d","type":"group","x":-2760,"y":-2711,"width":1353,"height":857,"label":"Multitasking"},
		{"id":"560c93ab6f9ab266","type":"group","x":500,"y":1340,"width":581,"height":1740,"label":"Asyncio Concepts"},
		{"id":"1ad33772b27e73f6","type":"group","x":1220,"y":1720,"width":960,"height":663,"label":"Multitasking Mistakes"},
		{"id":"421cfe113ad8fe7b","type":"group","x":-26,"y":-2806,"width":646,"height":180,"color":"5","label":"Memory of Threads and Processes"},
		{"id":"ecddfe86f51804bf","type":"text","text":"## Socket\nA socket is an abstraction for sending and receiving data\nTwo main operations:\n- sending bytes\n- receiving bytes","x":121,"y":62,"width":490,"height":258},
		{"id":"da6716373fe172d4","type":"text","text":"### Blocking sockets\nUsed by default\n**Pause the application during the entire wait for a response**","x":-280,"y":380,"width":401,"height":336},
		{"id":"f988f3f4375d9ab4","type":"text","text":"### Non-blocking sockets\nAllows you to perform other tasks while waiting — **the OS notifies when bytes are received**, and you can return to processing\n\nNotification tools differ by OS:\n- kqueue - macOS, FreeBSD\n- epoll - Linux\n- IOCP - Windows","x":599,"y":380,"width":378,"height":362},
		{"id":"6bd90b308626e056","type":"text","text":"**The OS monitors non-blocking sockets and notifies when data arrives. A single thread with asyncio handles these events, enabling cooperative concurrency without multithreading.**\n\n#### This underlies asyncio concurrency","x":543,"y":780,"width":490,"height":280,"color":"3"},
		{"id":"08d7a721119fd9b9","type":"text","text":"1. An infinite loop checks in each iteration if there is a ready task in the queue\n\t1. If there is, it **executes until it hits an I/O operation**\n\t2. At that point, the task **is paused and we ask the OS to monitor the sockets**\n2. Meanwhile, it proceeds to the next ready task\n3. On each iteration it checks if any task's I/O operation is complete\n\t1. If so, it resumes the task and continues execution","x":519,"y":2680,"width":535,"height":380},
		{"id":"3436cd773d7353fe","type":"text","text":"# Asyncio\n\nA Python library for writing **asynchronous, single-threaded code** that handles **I/O operations** (network, files, etc.) efficiently without blocking execution.","x":528,"y":1402,"width":516,"height":181,"color":"1"},
		{"id":"e952960c344a59ad","type":"text","text":"## Single-threaded Concurrency\n\nTo handle I/O concurrently, one thread and one process is enough. This is possible because I/O operations run concurrently at the OS level.\n\n**Asynchronous concurrency** in asyncio is based on:\n\n- **Reactive I/O handling** (notifications from the OS),\n    \n- and **cooperative task switching** using `await`.","x":541,"y":1960,"width":490,"height":369},
		{"id":"f6a7a49ed5cadaed","type":"text","text":"## Event Loop\n\nThe heart of any asyncio application.\n\nA queue is created into which events or messages are added and then processed in an infinite loop as they arrive.","x":546,"y":2363,"width":480,"height":280},
		{"id":"12de8bee1dbdb9fd","type":"text","text":"### **Coroutine** (inherits from Awaitable)\nA coroutine in Python looks like a normal function but with a twist: **it can pause execution during long operations**\n\n- **async** — defines a coroutine\n- **await** — pauses execution until the result is ready\n\n**Coroutines don't run when called directly. They return a coroutine object!**\n\nTo run a coroutine, you must explicitly schedule it in the event loop:\n- either await it directly,\n- or wrap it in a Task using `asyncio.create_task()`","x":169,"y":3912,"width":508,"height":508},
		{"id":"61613bc7a7eba894","type":"text","text":"### Core asyncio Functions and Syntax","x":516,"y":5070,"width":529,"height":77,"color":"1"},
		{"id":"43a350b38a0da79e","type":"text","text":"### async def\n\nDefines a **coroutine** — a special function that can be paused using `await`.\n\n```\nasync def fetch():\n    await asyncio.sleep(n)\n    return f\"Done {n}\"\n```\n\n**A coroutine cannot be called directly — it returns a coroutine object. To run it, use `await` or wrap it in a Task.**\n\n```\nresult = fetch(1)\nprint(result)\n# <coroutine object fetch at 0x...>\n\nresult = await fetch(1)\nprint(result)\n# Done 1\n```","x":-419,"y":5328,"width":470,"height":682},
		{"id":"e7b32395e995cf35","type":"text","text":"### await\n\nPauses the coroutine. Code inside it does not execute until the awaited value is returned.\nIt does **not block the thread**, allowing other tasks to run concurrently.\n```\nasync def fetch(n):\n    await asyncio.sleep(n)\n    return f\"Done {n}\"\n\nawait fetch(1)\n```\n---\n> Note: in this use (sequential await), calls are executed one after another, like in synchronous code.\n```\nasync def main():\n    result_1 = await fetch(1)\n    result_2 = await fetch(2)\n    result_3 = await fetch(3)\n```","x":181,"y":5328,"width":547,"height":682},
		{"id":"ff31d17fd0b31d77","type":"text","text":"### asyncio.run()\n\nCreates a new event loop, runs the given coroutine to completion, and returns the result. It stops and closes the event loop afterward.\n\nIntended as the main entry point for an asyncio application. It runs a single coroutine that should manage all others.\n\n```  \nasync def fetch(n):\n    await asyncio.sleep(n)\n    return f\"Done {n}\"\n\nasync def main():\n    results = await asyncio.gather(\n        fetch(1),\n        fetch(2),\n        fetch(3)\n    )\n    for r in results:\n        print(r)\n\nasyncio.run(main())\n```","x":807,"y":5328,"width":547,"height":682},
		{"id":"385f7abe3da08828","type":"text","text":"### asyncio.sleep()\n\nAsynchronous pause that **does not block** other tasks.\nUsed for:\n- I/O simulation\n- throttling\n- creating delays without blocking the event loop\n\nUnlike `time.sleep()`, it does not halt the thread.\n","x":1451,"y":5328,"width":547,"height":682},
		{"id":"3a6858a48bd933d3","type":"text","text":"### **Task** (inherits from Future)\nA specialized Future that wraps a coroutine and manages its execution in the event loop.\n- Manages the coroutine's lifecycle.\n- On completion, stores the result or exception in the internal Future.","x":880,"y":4500,"width":533,"height":309},
		{"id":"d584fcef1073d8b5","type":"text","text":"## Asyncio DOES NOT BYPASS the GIL\n\n#### Asyncio uses GIL release during I/O operations\nFor concurrent computation tasks, you'll still need a separate PROCESS","x":528,"y":1642,"width":516,"height":260,"color":"1"},
		{"id":"2a31f2f086ffc165","type":"text","text":"### asyncio.create_task\nThe function `asyncio.create_task(coro)` creates a Task from a coroutine and schedules it for execution in the event loop.\n\nAllows running multiple coroutines concurrently — they execute independently until awaited.\n\n**The task starts as soon as possible, without blocking other code.**\n\n```\ntask = asyncio.create_task(do_something())\n```","x":564,"y":7120,"width":485,"height":420},
		{"id":"4109df72862e8b17","type":"text","text":"### asyncio.wait\nAllows waiting for a set of tasks to complete.\nReturns two sets: done and pending.\n\n---\n**asyncio.wait() does NOT wrap coroutines in Tasks!!**\n\n> Note: if you don't use `create_task`, coroutines only start when `await` is called. In this case, **there is no concurrency**, everything runs sequentially.\n\nCorrect usage with `create_task`\n```\ndone, pending = await asyncio.wait([\n  asyncio.create_task(do_1()),\n  asyncio.create_task(do_2())\n])\n```\n\nThe `return_when` parameter controls when it returns:\n- ALL_COMPLETED — waits for **all tasks** to finish (default).\n- FIRST_COMPLETED — returns when **the first task completes**.\n- FIRST_EXCEPTION — returns as soon as **any task raises an exception**.","x":865,"y":7680,"width":514,"height":880},
		{"id":"10c89f4f34232a41","type":"text","text":"## Cancelling Tasks\n\n- **task.cancel()** — raises CanceledError. Does not interrupt the task, only cancels if it's at an await point.\n\n- **asyncio.wait_for()** — sets a timeout for a task.\n- **asyncio.shield()** — protects a task from being cancelled.","x":1162,"y":6607,"width":520,"height":403},
		{"id":"5611456618bf3223","type":"text","text":"### asyncio.wait_for\nSets a timeout for a coroutine.\nIf it doesn't finish within the time — `asyncio.TimeoutError` is raised.\n\n---\n**asyncio.wait_for() automatically wraps coroutines in a Task**\n\n```\nawait asyncio.wait_for(do_something(), timeout=5)\n```\n\n> If the timeout is exceeded — the task is **cancelled** (you can catch CancelledError inside).","x":1488,"y":7680,"width":514,"height":880},
		{"id":"95f7089ba04662c3","type":"text","text":"# Tasks and Parallelism","x":542,"y":6400,"width":529,"height":77,"color":"1"},
		{"id":"bf9cc2b7aa7f9fa2","type":"text","text":"### task\n\nA task (`asyncio.Task`) is a wrapper around a coroutine that schedules it automatically in the event loop.  \n\nOnce created, the task is queued and starts running as soon as possible.  \n\nCreating a task does not block program execution — the event loop continues processing other tasks.","x":564,"y":6600,"width":485,"height":417},
		{"id":"4167136b707d3145","type":"text","text":"### asyncio.gather\nAllows concurrent execution of multiple coroutines and waits for their completion.\n\nAll coroutines are started simultaneously, and results are returned in a list **in the same order they were passed to asyncio.gather, regardless of their actual completion order**.\n\n---\n**asyncio.gather() automatically wraps coroutines in a Task**\n\n```\nawait asyncio.gather(do_1(), do_2(), do_3())\n```\n\nIf `return_exceptions=True` is passed, gather does not stop on exceptions — instead, it returns them in the resulting list.\nThis allows handling errors manually without failing the whole group of tasks.\n```\nresults = await asyncio.gather(\n    do_ok(), do_fail(), return_exceptions=True\n)\n# results = [result, Exception(...)]\nfor i, result in enumerate(results):\n    if isinstance(result, Exception):\n        print(f\"Task {i} raised an exception\")\n    else:\n        print(f\"Task {i} completed successfully\")\n```","x":-395,"y":7680,"width":514,"height":900},
		{"id":"be04caa1a466a87a","type":"text","text":"### asyncio.as_completed\nAn iterator that yields results as coroutines complete. It doesn’t wait for all to finish. **The order of results reflects the order of completion, not the order of invocation.**\n\n---\n**asyncio.as_completed() does NOT wrap coroutines in a Task!!**\n\n> Note: if you don't use `create_task`, coroutines only start when `await` is called. In this case, **there is no concurrency**, everything runs sequentially.\n\n```\nfor coro in asyncio.as_completed([\n  do_1(), do_2()\n]):\n    result = await coro\n```\nCorrect usage with `create_task`\n```\nfor task in asyncio.as_completed([\n  asyncio.create_task(do_1()),\n  asyncio.create_task(do_2())\n]):\n    result = await task\n```","x":245,"y":7680,"width":514,"height":880},
		{"id":"3d32df03720436ca","type":"text","text":"### Main asyncio Objects","x":530,"y":3320,"width":529,"height":77,"color":"1"},
		{"id":"1538d5c481574fa0","type":"text","text":"# Code Synchronization","x":459,"y":8960,"width":600,"height":80,"color":"1"},
		{"id":"b766d96f64eae88e","type":"text","text":"### Awaitable\n\nAn abstraction representing any object that can be “awaited” using `await`.\n- Defines a single abstract method `__await__`\n- All objects that can be used with `await` implement this method.","x":527,"y":3480,"width":535,"height":260},
		{"id":"18c42c0cb1073c81","type":"text","text":"### **Future** (inherits from Awaitable)\nAn object representing a result that will be available in the future.\n\n- When created, it is considered **incomplete**.\n\n- Once the result is ready (set manually or automatically), it becomes accessible via `.result()` or `await`.","x":890,"y":3900,"width":512,"height":520},
		{"id":"f159503df922190b","type":"text","text":"#### C-extensions that explicitly release the GIL\n\nWhen calling external C functions, you can manage the GIL explicitly:\n- In cffi there's an option `with gil / without gil`\n- In ctypes you can wrap the call in a C function that manually releases the GIL","x":-482,"y":-520,"width":467,"height":309},
		{"id":"f484c000acdf5802","type":"text","text":"### I/O operations\n\nThe GIL is released during I/O operations:\n- Working with sockets\n- Reading/writing files\n- Accessing databases via C-extensions","x":133,"y":-520,"width":467,"height":309},
		{"id":"c082273cc0582aa1","type":"text","text":"#### Built-in functions and modules implemented in C\n\n- Examples: zlib, bz2, hashlib, json, sqlite3, PIL — may release the GIL during heavy internal operations.\n    \n- NumPy and SciPy often release the GIL during mathematical operations (depending on implementation).","x":760,"y":-520,"width":467,"height":309},
		{"id":"d2a8b5499bdd9de4","type":"text","text":"# GIL\n**The GIL allows only one Python interpreter thread to execute bytecode at any given moment.**\n\nAs a result, multithreading in Python offers little benefit for computational tasks, except for I/O operations and calls to external code (e.g., C libraries) that do not rely on the GIL.","x":133,"y":-1580,"width":467,"height":280,"color":"6"},
		{"id":"8752d3d68fb10c7c","type":"text","text":"### Operations that release the GIL\n\nLow-level systems that **operate outside the Python environment**","x":133,"y":-760,"width":467,"height":180},
		{"id":"9c9bde0e160eb265","type":"text","text":"## Errors in single-threaded concurrency\n\nSince asyncio uses a **single-threaded concurrency model**, race conditions are possible **only when there is an await between accesses to shared data**.\nThis differs from multithreading, where races can occur **at any moment** shared resources are modified.\n\n```\nimport asyncio  \n\nn = 0  \nlock = asyncio.Lock()  \n\nasync def increment():  \n    global n  \n    temp_n = n  \n    await asyncio.sleep(0.01)  \n    n = temp_n + 1  \n\nasync def main():  \n    global n  \n    await asyncio.gather(*[increment() for _ in range(100)])  \n    print(n)  \n    assert n == 100\n```\n\n**In single-threaded concurrency, errors from non-atomic operations won’t happen if there’s no await in between.**\n\nFor example, integer increment (`n += 1`) is non-atomic: it consists of reading, adding, and writing.\n\nHowever, if execution cannot be interrupted (i.e., no await between these steps), there is no race condition.\n\nSo if we remove `await asyncio.sleep(0.01)` from the example above, the program will behave correctly and give consistent results.\n","x":-221,"y":9280,"width":600,"height":1020},
		{"id":"8b79bef53fcde5bd","type":"text","text":"## asyncio.Semaphore\nLimits the **number of concurrently running tasks**.\n\nWhen the limit is reached — new tasks wait. This constrains “parallelism,” useful for working with APIs, databases, files, etc.\n\n---\n```\nsem = asyncio.Semaphore(3)\nasync def limited_task(n):\n    async with sem:\n        print(f\"Start {n}\")\n        await asyncio.sleep(2)\n        print(f\"End {n}\")\n\nasync def main():\n    tasks = [limited_task(i) for i in range(6)]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n```\n\n- **Only 3 tasks** (0, 1, 2) start at the same time.\n- Others (3, 4, 5) **wait** for a slot to free up.\n- Once the first finish, the next begin.\n","x":459,"y":9280,"width":600,"height":1020},
		{"id":"224c426bcecbfb51","type":"text","text":"## asyncio.BoundedSemaphore\nSame as Semaphore, but raises an error if you try to release more than acquired.\nUseful for debugging misuse of semaphores.\n\n**This is impossible if you always use semaphores via the context manager `async with Semaphore(...)`**\n\n---\n```\nasync def limited_task():\n    sem = asyncio.BoundedSemaphore(2)\n\n    await sem.acquire()\n    sem.release()\n    sem.release()  # ValueError: BoundedSemaphore released too many times\n\nasyncio.run(limited_task())\n```\n","x":1139,"y":9280,"width":600,"height":1020},
		{"id":"851e50e0d0d6807b","type":"text","text":"### WHY DOES THE GIL EXIST?\n\nIn CPython, memory management is mostly based on reference counting.\n\n**Reference counting is a non-atomic operation (includes reading and writing values).**\n\nBecause of this, CPython is not thread-safe:\n\n- **if multiple threads modify a variable at the same time, its value can be corrupted due to a race condition**","x":133,"y":-1220,"width":467,"height":418},
		{"id":"852a9cbd4c9159f7","type":"text","text":"**Each process is associated with at least one thread by default — the main thread**.\n\nA process can create additional worker (background) threads.","x":-212,"y":-2333,"width":320,"height":205},
		{"id":"ac80ac6a020a78c5","type":"text","text":"### Preemptive\nThe operating system decides how to switch tasks using time-slicing mechanisms.\n","x":-2740,"y":-2500,"width":373,"height":239},
		{"id":"40993f24e786a799","type":"text","text":"# Multitasking\n","x":-2484,"y":-2691,"width":341,"height":70},
		{"id":"197a2c6431913afa","type":"text","text":"### Cooperative\nTasks define specific points (e.g., using await) where they pause and yield control to others","x":-2267,"y":-2500,"width":373,"height":239},
		{"id":"c20933b26166dd5b","type":"text","text":"In cooperative multitasking, a task can pause (sleep) and give control to another — this creates a form of concurrency: multiple tasks are active logically at the same time, but not in parallel, as they execute sequentially in one thread.\n\n**Asyncio implements this exact model**","x":-2272,"y":-2181,"width":383,"height":290},
		{"id":"13382b344a59130c","type":"text","text":"# Process\nAn application with its **own memory space**, inaccessible to other applications","x":-650,"y":-2333,"width":334,"height":205,"color":"3"},
		{"id":"049a3ce0bbd301dd","type":"text","text":"- Consumes fewer resources  \n- Granularity — we explicitly mark the most beneficial pause points","x":-1800,"y":-2450,"width":373,"height":140},
		{"id":"70d16cb22d93995b","type":"text","text":"**On a single-core processor**, concurrent execution is still possible due to OS scheduling and time slicing","x":-1190,"y":-2207,"width":366,"height":107},
		{"id":"155bff9542a5538c","type":"text","text":"## Multiprocessing\nA process can spawn new processes, manage them, and distribute work.\nEach process has its **own allocated memory.**","x":-716,"y":-2008,"width":467,"height":208},
		{"id":"1f3a529c5bba4526","type":"text","text":"A typical Python application creates a **process and a main thread**","x":-650,"y":-2580,"width":334,"height":120,"color":"5"},
		{"id":"c24d1be1240bfdb0","type":"text","text":"Worker Thread","x":424,"y":-2696,"width":176,"height":50,"color":"4"},
		{"id":"44a68b105f19162b","type":"text","text":"# Relationship Between Processes and Threads\n","x":-698,"y":-2786,"width":431,"height":98},
		{"id":"ca7b81d1f96e8629","type":"text","text":"Main thread","x":-6,"y":-2696,"width":188,"height":50,"color":"4"},
		{"id":"58e33e1ca9c99f46","type":"text","text":"# Multithreading\nA process can spawn many threads, which **share memory with the parent process** and run concurrently.\n","x":133,"y":-2008,"width":467,"height":208},
		{"id":"0748ab1e70e639e7","type":"text","text":"**Process memory**","x":202,"y":-2786,"width":192,"height":50,"color":"3"},
		{"id":"591966c265a358e7","type":"text","text":"# Thread\nThreads **do not have their own dedicated memory**, and use the memory of the parent PROCESS.","x":206,"y":-2333,"width":320,"height":205,"color":"4"},
		{"id":"7e7dda3378a2777f","type":"text","text":"Worker thread","x":210,"y":-2696,"width":177,"height":50,"color":"4"},
		{"id":"f5c9abb850849a24","type":"text","text":"**On a multi-core processor**, several processes can run SIMULTANEOUSLY","x":-1190,"y":-2387,"width":366,"height":113},
		{"id":"10f46d91bcaf7be8","type":"text","text":"## asyncio.Lock\nAsynchronous **mutual exclusion lock** (mutex).\n\nGuarantees that **only one task** executes the critical section at a time.\n\n---\n```\nimport asyncio  \n\nn = 0  \nlock = asyncio.Lock()  \nasync def increment():  \n  global n  \n  async with lock:  \n      temp_n = n  \n      await asyncio.sleep(0.01)  \n      n = temp_n + 1    \n\nasync def main():  \n  global n  \n  await asyncio.gather(*[increment() for _ in range(1000)])  \n  assert n == 1000  \n  \nasyncio.run(main())\n```\n","x":-221,"y":10380,"width":600,"height":900},
		{"id":"94457a7b1635634a","type":"text","text":"##### Multiprocessing applications can run simultaneously because **each process has its own GIL**\n","x":-716,"y":-1530,"width":467,"height":180,"color":"#fa7900"},
		{"id":"2da27f2c5effa163","type":"text","text":"#### Running compute-bound code in tasks and coroutines without multiprocessing\n\nAsyncio runs in a single thread, so GIL limitations still apply.","x":1240,"y":1934,"width":431,"height":283},
		{"id":"c362a13406e29de4","type":"text","text":"**Can be solved with multiprocessing**","x":1240,"y":2294,"width":431,"height":69},
		{"id":"e324d7f660346594","type":"text","text":"## Common Mistakes","x":1574,"y":1742,"width":301,"height":60},
		{"id":"ca8ffb6cba38b33b","type":"text","text":"#### Using blocking I/O APIs without multithreading\n\nExamples: requests, time.sleep, boto3, and others.\n\nIn general — any I/O function that is not a coroutine is considered blocking.","x":1724,"y":1934,"width":431,"height":283},
		{"id":"c9926edb6dd93834","type":"text","text":"**Can be solved with multithreading**","x":1724,"y":2294,"width":431,"height":63}
	],
	"edges":[
		{"id":"8a46ef9e02f78daa","fromNode":"13382b344a59130c","fromSide":"left","toNode":"f5c9abb850849a24","toSide":"right"},
		{"id":"38f881b55aa2673f","fromNode":"13382b344a59130c","fromSide":"left","toNode":"70d16cb22d93995b","toSide":"right"},
		{"id":"af872800397f7dc0","fromNode":"155bff9542a5538c","fromSide":"bottom","toNode":"94457a7b1635634a","toSide":"top"},
		{"id":"5b36b14fb76c87cc","fromNode":"13382b344a59130c","fromSide":"bottom","toNode":"155bff9542a5538c","toSide":"top"},
		{"id":"2a00a9dc819ba562","fromNode":"13382b344a59130c","fromSide":"right","toNode":"852a9cbd4c9159f7","toSide":"left"},
		{"id":"c22d8f14c63a7386","fromNode":"1f3a529c5bba4526","fromSide":"bottom","toNode":"13382b344a59130c","toSide":"top"},
		{"id":"81b0f238116bfca4","fromNode":"58e33e1ca9c99f46","fromSide":"bottom","toNode":"d2a8b5499bdd9de4","toSide":"top"},
		{"id":"ba60b534c82c0f14","fromNode":"591966c265a358e7","fromSide":"bottom","toNode":"58e33e1ca9c99f46","toSide":"top"},
		{"id":"1f96b46abee5befb","fromNode":"852a9cbd4c9159f7","fromSide":"right","toNode":"591966c265a358e7","toSide":"left"},
		{"id":"de29b625d53076ee","fromNode":"94457a7b1635634a","fromSide":"right","toNode":"d2a8b5499bdd9de4","toSide":"left"},
		{"id":"d3eb79767f1e9244","fromNode":"8752d3d68fb10c7c","fromSide":"left","toNode":"f159503df922190b","toSide":"top"},
		{"id":"38d2c8d082295f19","fromNode":"8752d3d68fb10c7c","fromSide":"bottom","toNode":"f484c000acdf5802","toSide":"top"},
		{"id":"489ab9f6ae13d269","fromNode":"8752d3d68fb10c7c","fromSide":"right","toNode":"c082273cc0582aa1","toSide":"top"},
		{"id":"db9b38fabe27fedf","fromNode":"44a68b105f19162b","fromSide":"bottom","toNode":"1f3a529c5bba4526","toSide":"top"},
		{"id":"71a59b459ba67f3f","fromNode":"40993f24e786a799","fromSide":"bottom","toNode":"ac80ac6a020a78c5","toSide":"top"},
		{"id":"1df22f389e38e944","fromNode":"40993f24e786a799","fromSide":"bottom","toNode":"197a2c6431913afa","toSide":"top"},
		{"id":"6cde1446c0d03d7f","fromNode":"197a2c6431913afa","fromSide":"right","toNode":"049a3ce0bbd301dd","toSide":"left"},
		{"id":"f73bd6e1724eb49f","fromNode":"197a2c6431913afa","fromSide":"bottom","toNode":"c20933b26166dd5b","toSide":"top"},
		{"id":"49c460e2693695d4","fromNode":"e952960c344a59ad","fromSide":"bottom","toNode":"f6a7a49ed5cadaed","toSide":"top"},
		{"id":"cc1bf1a8a93c9e4a","fromNode":"f6a7a49ed5cadaed","fromSide":"bottom","toNode":"08d7a721119fd9b9","toSide":"top"},
		{"id":"e3dd9518f8ca0fb3","fromNode":"ecddfe86f51804bf","fromSide":"right","toNode":"f988f3f4375d9ab4","toSide":"top"},
		{"id":"0ec3473b12c4cb81","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"e7b32395e995cf35","toSide":"top"},
		{"id":"fbfe9e1e5a89cef6","fromNode":"bf9cc2b7aa7f9fa2","fromSide":"bottom","toNode":"2a31f2f086ffc165","toSide":"top"},
		{"id":"b2cf212cf31fca48","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"ff31d17fd0b31d77","toSide":"top"},
		{"id":"46198a40a7995535","fromNode":"3d32df03720436ca","fromSide":"bottom","toNode":"b766d96f64eae88e","toSide":"top"},
		{"id":"aeea8b8afe696774","fromNode":"b766d96f64eae88e","fromSide":"bottom","toNode":"12de8bee1dbdb9fd","toSide":"top"},
		{"id":"f77ce16252af4e5f","fromNode":"b766d96f64eae88e","fromSide":"bottom","toNode":"18c42c0cb1073c81","toSide":"top"},
		{"id":"761e4b22992cf394","fromNode":"ecddfe86f51804bf","fromSide":"left","toNode":"da6716373fe172d4","toSide":"top"},
		{"id":"af4a7e3b119621ea","fromNode":"18c42c0cb1073c81","fromSide":"bottom","toNode":"3a6858a48bd933d3","toSide":"top"},
		{"id":"618c0f1fa5474eaa","fromNode":"e324d7f660346594","fromSide":"bottom","toNode":"2da27f2c5effa163","toSide":"top"},
		{"id":"ca1f91146802e39d","fromNode":"e324d7f660346594","fromSide":"bottom","toNode":"ca8ffb6cba38b33b","toSide":"top"},
		{"id":"2ab5170f7f968ce2","fromNode":"2da27f2c5effa163","fromSide":"bottom","toNode":"c362a13406e29de4","toSide":"top"},
		{"id":"a1b133c9ee07965f","fromNode":"ca8ffb6cba38b33b","fromSide":"bottom","toNode":"c9926edb6dd93834","toSide":"top"},
		{"id":"2105d72d7fa92a67","fromNode":"f484c000acdf5802","fromSide":"bottom","toNode":"ecddfe86f51804bf","toSide":"top"},
		{"id":"98f26bb09db56f06","fromNode":"f988f3f4375d9ab4","fromSide":"bottom","toNode":"6bd90b308626e056","toSide":"top"},
		{"id":"75c7454f212a9bb5","fromNode":"6bd90b308626e056","fromSide":"bottom","toNode":"3436cd773d7353fe","toSide":"top"},
		{"id":"a5e0e0df93a5fecb","fromNode":"0748ab1e70e639e7","fromSide":"left","toNode":"ca7b81d1f96e8629","toSide":"top"},
		{"id":"466e2716840d874c","fromNode":"0748ab1e70e639e7","fromSide":"right","toNode":"c24d1be1240bfdb0","toSide":"top"},
		{"id":"3135e7b26e738086","fromNode":"0748ab1e70e639e7","fromSide":"bottom","toNode":"7e7dda3378a2777f","toSide":"top"},
		{"id":"e66d40f51c5b6013","fromNode":"3436cd773d7353fe","fromSide":"bottom","toNode":"d584fcef1073d8b5","toSide":"top"},
		{"id":"fd63ac27678ee762","fromNode":"d584fcef1073d8b5","fromSide":"bottom","toNode":"e952960c344a59ad","toSide":"top"},
		{"id":"730e029e98ab245b","fromNode":"d2a8b5499bdd9de4","fromSide":"bottom","toNode":"851e50e0d0d6807b","toSide":"top"},
		{"id":"56dea0e6872c3f58","fromNode":"851e50e0d0d6807b","fromSide":"bottom","toNode":"8752d3d68fb10c7c","toSide":"top"},
		{"id":"2423a2ae39b30559","fromNode":"d584fcef1073d8b5","fromSide":"right","toNode":"e324d7f660346594","toSide":"left"},
		{"id":"82df4c3ef522c571","fromNode":"2a31f2f086ffc165","fromSide":"bottom","toNode":"be04caa1a466a87a","toSide":"top"},
		{"id":"f90dc305fa626ac3","fromNode":"2a31f2f086ffc165","fromSide":"bottom","toNode":"4109df72862e8b17","toSide":"top"},
		{"id":"772e66ab4cec262f","fromNode":"2a31f2f086ffc165","fromSide":"left","toNode":"4167136b707d3145","toSide":"top"},
		{"id":"db4e83c7b2b30b67","fromNode":"2a31f2f086ffc165","fromSide":"right","toNode":"5611456618bf3223","toSide":"top"},
		{"id":"0132f6cc61c80227","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"43a350b38a0da79e","toSide":"top"},
		{"id":"7ebf227bcbd2fb7c","fromNode":"61613bc7a7eba894","fromSide":"bottom","toNode":"385f7abe3da08828","toSide":"top"},
		{"id":"8ce26e89bf81adde","fromNode":"95f7089ba04662c3","fromSide":"bottom","toNode":"bf9cc2b7aa7f9fa2","toSide":"top"},
		{"id":"996578eec0ca705e","fromNode":"bf9cc2b7aa7f9fa2","fromSide":"right","toNode":"10c89f4f34232a41","toSide":"left"},
		{"id":"e228bd290471e31e","fromNode":"550bb4cdb88d00dc","fromSide":"bottom","toNode":"046b86d6e0de2d15","toSide":"top"},
		{"id":"9c9d954badb607fc","fromNode":"87bca9eb62cc9614","fromSide":"bottom","toNode":"550bb4cdb88d00dc","toSide":"top"},
		{"id":"613cb765374dab17","fromNode":"560c93ab6f9ab266","fromSide":"bottom","toNode":"87bca9eb62cc9614","toSide":"top"},
		{"id":"f048609c86371e51","fromNode":"1538d5c481574fa0","fromSide":"bottom","toNode":"8b79bef53fcde5bd","toSide":"top"},
		{"id":"365c7999e7e9022f","fromNode":"1538d5c481574fa0","fromSide":"bottom","toNode":"224c426bcecbfb51","toSide":"top"},
		{"id":"6fc8eeed3adf0e63","fromNode":"1538d5c481574fa0","fromSide":"bottom","toNode":"9c9bde0e160eb265","toSide":"top"},
		{"id":"a2539bd831016265","fromNode":"9c9bde0e160eb265","fromSide":"bottom","toNode":"10f46d91bcaf7be8","toSide":"top"},
		{"id":"46b71ed2d772851c","fromNode":"046b86d6e0de2d15","fromSide":"bottom","toNode":"95d2c104c01c39c2","toSide":"top"},
		{"id":"7a7619de2012b30b","fromNode":"cd4744afca6bcc2d","fromSide":"right","toNode":"16affb269abfc7bf","toSide":"left"}
	]
}